// #include <micro_ros_arduino.h>
#include <Arduino.h>
#include <micro_ros_platformio.h>

// #include <stdio.h>
#include <rcl/rcl.h>
// #include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>

#include <std_msgs/msg/u_int32.h>
#include <geometry_msgs/msg/twist.h>
#include <my_custom_message/msg/velocidad_motor_message.h>
#include <my_custom_message/msg/mcu_message.h>

#include "RoboClaw.h"


#include <SimpleDHT.h>

#define LED_PIN 13

#define RCCHECK(fn)              \
  {                              \
    rcl_ret_t temp_rc = fn;      \
    if ((temp_rc != RCL_RET_OK)) \
    {                            \
      error_loop();              \
    }                            \
  }
#define RCSOFTCHECK(fn)          \
  {                              \
    rcl_ret_t temp_rc = fn;      \
    if ((temp_rc != RCL_RET_OK)) \
    {                            \
    }                            \
  }

#define RCLOOPCHECK(fn)          \
  {                              \
    rcl_ret_t temp_rc = fn;      \
    if ((temp_rc != RCL_RET_OK)) \
    {                            \
      error_loop_loop();         \
    }                            \
  }

// Velocity PID coefficients.
//  #define Kp 2.17968
//  #define Ki 0.29667
//  #define Kd 0.00000
//  #define qpps 8200

#define Kp 2.17968
#define Ki 0.1
#define Kd 0.00000
#define qpps 8200

#define address1 0x81
#define address2 0x80
#define address3 0x82

#define ACCEL_MAX 16000
#define SPEED_MAX 8000
#define SPEED_MIN 2500
#define SPEED_DEFAULT 2500

#define DHT22_DATA 9

#define IN_00 30
#define IN_01 31

#define PERIODO_00 100
#define PERIODO_01 200
#define PERIODO_02 500
uint32_t cont_00 = 0;
uint32_t cont_01 = 0;
uint32_t cont_02 = 0;

rcl_allocator_t allocator;
rclc_support_t support;

rcl_node_t node;

// Subscriptor 01
rcl_subscription_t subscriber_01;
geometry_msgs__msg__Twist msg_velocidad;
rclc_executor_t executor_sub_01;

// Subscriptor 02
rcl_subscription_t subscriber_02;
std_msgs__msg__UInt32 msg_velocity;
rclc_executor_t executor_sub_02;
uint32_t speed = SPEED_DEFAULT;

// Publicador 01
rcl_publisher_t publisher_01;
my_custom_message__msg__McuMessage msg_mcu;
rclc_executor_t executor_pub_01;
rcl_timer_t timer_01;

// Publicador 03
rcl_publisher_t publisher_02;
my_custom_message__msg__VelocidadMotorMessage msg_velocidad_motor;
rclc_executor_t executor_pub_02;
rcl_timer_t timer_02;

RoboClaw roboclaw(&Serial8, 10000);

uint32_t speed1 = 0;
uint32_t speed2 = 0;
uint32_t speed3 = 0;
uint32_t speed4 = 0;
uint32_t speed5 = 0;

Ultrasonic HSR_01(SR04_1_TRIGGER, SR04_1_ECHO); // (Trig PIN,Echo PIN)
Ultrasonic HSR_02(SR04_2_TRIGGER, SR04_2_ECHO);
Ultrasonic HSR_03(SR04_3_TRIGGER, SR04_3_ECHO);
Ultrasonic HSR_04(SR04_4_TRIGGER, SR04_4_ECHO);
Ultrasonic HSR_05(SR04_5_TRIGGER, SR04_5_ECHO);
Ultrasonic HSR_06(SR04_6_TRIGGER, SR04_6_ECHO);
Ultrasonic HSR_07(SR04_7_TRIGGER, SR04_7_ECHO);
Ultrasonic HSR_08(SR04_8_TRIGGER, SR04_8_ECHO);
Ultrasonic HSR_09(SR04_9_TRIGGER, SR04_9_ECHO);

U8G2_ST7920_128X64_1_SW_SPI u8g2(U8G2_R0, 13, 11, 10, 25); // obj, clk, data, cs, reset
uint8_t draw_state = 0;

SimpleDHT22 dht22(DHT22_DATA);
float temperatura = 0;
float humedad = 0;

uint8_t pin_tijeral_limite_inferior = IN_01;
uint8_t pin_tijeral_limite_superior = IN_00;

uint8_t pin_piloto_rojo = RELAY_1;
uint8_t pin_piloto_amarillo = RELAY_0;

uint8_t f_error_ros = 0;

float bat = 0.0;
float x11 = 22500.0;
float y11 = 25.8;
float x00 = -2700.0;
float y00 = 0.0;
float m = (y11 - y00) / (x11 - x00);
float b = y11 - m * x11;

float read_battery_voltage()
{
  int32_t val_23 = 0;
  for (int N = 0; N < 10; N++)
  {
    val_23 += ADS.readADC_Differential_2_3();
  }

  // return ADS.toVoltage(val_23) *13;
  return (val_23 / 10.0) * m + b;
}


void set_tijeral_limite_inferior()
{

  while (digitalRead(pin_tijeral_limite_inferior) == 0)
  {
    digitalWrite(RELAY_2, !digitalRead(RELAY_2));
    roboclaw.ForwardM1(address3, 100);
    delay(50);
  }
  roboclaw.ForwardM1(address3, 0);
}


void set_tijeral_limite_superior()
{

  while (digitalRead(pin_tijeral_limite_superior) == 0)
  {
    digitalWrite(RELAY_2, !digitalRead(RELAY_2));
    roboclaw.BackwardM1(address3, 100);
    delay(50);
  }
  roboclaw.BackwardM1(address3, 0);
}


void error_loop()
{
  while (1)
  {
    digitalWrite(LED_PIN, !digitalRead(LED_PIN));
    delay(100);
  }
}


void timer_01_callback(rcl_timer_t *timer, int64_t last_call_time)
{
  RCLC_UNUSED(last_call_time);
  if (timer != NULL)
  {
    msg_mcu.sensor_01 = HSR_01.CalcularDistancia(HS_CM);
    msg_mcu.sensor_02 = HSR_02.CalcularDistancia(HS_CM);
    msg_mcu.sensor_03 = HSR_03.CalcularDistancia(HS_CM);
    msg_mcu.sensor_04 = HSR_04.CalcularDistancia(HS_CM);
    msg_mcu.sensor_05 = HSR_05.CalcularDistancia(HS_CM);
    msg_mcu.sensor_06 = HSR_06.CalcularDistancia(HS_CM);
    msg_mcu.sensor_07 = HSR_07.CalcularDistancia(HS_CM);
    msg_mcu.sensor_08 = HSR_08.CalcularDistancia(HS_CM);
    msg_mcu.sensor_09 = HSR_09.CalcularDistancia(HS_CM);

    msg_mcu.temperatura = temperatura;
    msg_mcu.humedad = humedad;
    msg_mcu.bat = bat;

    msg_mcu.e_f_d = digitalRead(pin_tijeral_limite_inferior);
    msg_mcu.e_f_i = digitalRead(pin_tijeral_limite_superior);

    RCSOFTCHECK(rcl_publish(&publisher_01, &msg_mcu, NULL));
  }
}


void timer_02_callback(rcl_timer_t *timer, int64_t last_call_time)
{
  RCLC_UNUSED(last_call_time);
  if (timer != NULL)
  {
    uint8_t status1, status2, status3, status4, status5;
    bool valid1, valid2, valid3, valid4, valid5;

    speed1 = roboclaw.ReadSpeedM1(address1, &status1, &valid1);
    speed2 = roboclaw.ReadSpeedM2(address1, &status2, &valid2);
    speed3 = roboclaw.ReadSpeedM1(address2, &status3, &valid3);
    speed4 = roboclaw.ReadSpeedM2(address2, &status4, &valid4);
    speed5 = roboclaw.ReadSpeedM1(address3, &status5, &valid5);

    msg_velocidad_motor.m_v = speed;
    msg_velocidad_motor.m_f_d = speed2;
    msg_velocidad_motor.m_p_d = speed1;
    msg_velocidad_motor.m_f_i = speed4;
    msg_velocidad_motor.m_p_i = speed3;
    msg_velocidad_motor.m_t = speed5;

    if (valid1 == 0)
    {
      speed1 = 9999;
    }
    if (valid2 == 0)
    {
      speed2 = 9999;
    }
    if (valid3 == 0)
    {
      speed3 = 9999;
    }
    if (valid4 == 0)
    {
      speed4 = 9999;
    }
    if (valid5 == 0)
    {
      speed5 = 9999;
    }

    if (digitalRead(pin_tijeral_limite_inferior) == 1)
    {
      msg_mcu.error = 7;
    }

    else if (digitalRead(pin_tijeral_limite_superior) == 1)
    {
      msg_mcu.error = 8;
    }
    else
    {
      msg_mcu.error = 0;
    }

    RCSOFTCHECK(rcl_publish(&publisher_02, &msg_velocidad_motor, NULL));
  }
}

int32_t roundToNearest(double value) {
    return (int32_t)(500 * round(value / 500.0));
}



void subscription_01_callback(const void *msgin)
{
  digitalWrite(RELAY_3, 1);
  // const std_msgs__msg__Int32 * msg = (const std_msgs__msg__Int32 *)msgin;
  const geometry_msgs__msg__Twist *msg_velocidad = (const geometry_msgs__msg__Twist *)msgin;
  digitalWrite(LED_PIN, (msg_velocidad->linear.x == 0) ? LOW : HIGH);

  if (msg_velocidad->linear.y == -255)
  {
    set_tijeral_limite_inferior();
  }
  if (msg_velocidad->linear.y == 255)
  {
    set_tijeral_limite_superior();
  }

  // PARAR
  if ((msg_velocidad->linear.x == 0) && (msg_velocidad->angular.z == 0))
  {
    // TODO: convertir rango de x a rango de velocidad
    // analizar convertir rango de x a rango de aceleracion
    roboclaw.SpeedAccelM1(address1, ACCEL_MAX, 0);
    roboclaw.SpeedAccelM2(address1, ACCEL_MAX, 0);
    roboclaw.SpeedAccelM1(address2, ACCEL_MAX, 0);
    roboclaw.SpeedAccelM2(address2, ACCEL_MAX, 0);
    // comentado porque la funcion SpeedAccelMx ya lo hace
    roboclaw.ForwardM1(address1, 0);
    roboclaw.ForwardM2(address1, 0);
    roboclaw.ForwardM1(address2, 0);
    roboclaw.ForwardM2(address2, 0);

    digitalWrite(RELAY_2, 0);
    digitalWrite(RELAY_3, 0);
  }

  if ((msg_velocidad->linear.z < 0) && (digitalRead(pin_tijeral_limite_inferior) == 0))
  {
    roboclaw.ForwardM1(address3, 100);
    delay(400);
    roboclaw.ForwardM1(address3, 0);
  }
  else if ((msg_velocidad->linear.z > 0) && (digitalRead(pin_tijeral_limite_superior) == 0))
  {
    roboclaw.BackwardM1(address3, 100);
    delay(400);
    roboclaw.BackwardM1(address3, 0);
  }
  // DIAGONAL izquierda
  else if ((msg_velocidad->angular.z > 0.3) && (digitalRead(pin_tijeral_limite_inferior) == 1))
  {
    digitalWrite(RELAY_2, !digitalRead(RELAY_2));
    
    // Obtener la velocidad y la aceleraci贸n normalizadas
    double normalized_speed = msg_velocidad->angular.z;

    // Truncar a un decimal
    normalized_speed = floor(normalized_speed * 10) / 10.0;

    // Mapear la velocidad y la aceleraci贸n normalizadas a los rangos deseados
    int32_t target_speed = roundToNearest((normalized_speed * speed));

    // analizar convertir rango de x a rango de aceleracion
    roboclaw.SpeedAccelM1(address1, ACCEL_MAX, target_speed);
    roboclaw.SpeedAccelM2(address1, ACCEL_MAX, target_speed);
    roboclaw.SpeedAccelM1(address2, ACCEL_MAX, target_speed);
    roboclaw.SpeedAccelM2(address2, ACCEL_MAX, target_speed);
  }
  // DIAGONAL derecha
  else if ((msg_velocidad->angular.z < -0.3) && (digitalRead(pin_tijeral_limite_inferior) == 1))
  {
    digitalWrite(RELAY_2, !digitalRead(RELAY_2));
    
    // Obtener el valor absoluto de la velocidad y la aceleraci贸n normalizadas
    double abs_normalized_speed = abs(msg_velocidad->angular.z);

    // Truncar a un decimal
    abs_normalized_speed = floor(abs_normalized_speed * 10) / 10.0;

    // Mapear el valor absoluto de la velocidad y la aceleraci贸n normalizadas a los rangos deseados
    int32_t target_speed = roundToNearest((abs_normalized_speed * speed));

    // analizar convertir rango de x a rango de aceleracion
    roboclaw.SpeedAccelM1(address1, ACCEL_MAX, -target_speed);
    roboclaw.SpeedAccelM2(address1, ACCEL_MAX, -target_speed);
    roboclaw.SpeedAccelM1(address2, ACCEL_MAX, -target_speed);
    roboclaw.SpeedAccelM2(address2, ACCEL_MAX, -target_speed);
  }
  // PA DELANTE
  else if (msg_velocidad->linear.x > 0 && (digitalRead(pin_tijeral_limite_inferior) == 1))
  {
    digitalWrite(RELAY_2, !digitalRead(RELAY_2));
    
    // Obtener la velocidad y la aceleraci贸n normalizadas
    double normalized_speed = msg_velocidad->linear.x;
    
    // Truncar a un decimal
    normalized_speed = floor(normalized_speed * 10) / 10.0;

    // Mapear la velocidad y la aceleraci贸n normalizadas a los rangos deseados
    int32_t target_speed = roundToNearest((normalized_speed * speed));

    // Controlar los motores con la velocidad y la aceleraci贸n calculadas
    roboclaw.SpeedAccelM1(address1, ACCEL_MAX, target_speed);
    roboclaw.SpeedAccelM2(address1, ACCEL_MAX, target_speed);
    roboclaw.SpeedAccelM1(address2, ACCEL_MAX, -target_speed);
    roboclaw.SpeedAccelM2(address2, ACCEL_MAX, -target_speed);
  }
  // PA ATRAS
  else if (msg_velocidad->linear.x < 0 && (digitalRead(pin_tijeral_limite_inferior) == 1))
  {
    digitalWrite(RELAY_2, !digitalRead(RELAY_2));

    // Obtener el valor absoluto de la velocidad y la aceleraci贸n normalizadas
    double abs_normalized_speed = abs(msg_velocidad->linear.x);

    // Truncar a un decimal
    abs_normalized_speed = floor(abs_normalized_speed * 10) / 10.0;

    // Mapear el valor absoluto de la velocidad y la aceleraci贸n normalizadas a los rangos deseados
    int32_t target_speed = roundToNearest((abs_normalized_speed * speed));

    // Controlar los motores con la velocidad y la aceleraci贸n calculadas
    roboclaw.SpeedAccelM1(address1, ACCEL_MAX, -target_speed);
    roboclaw.SpeedAccelM2(address1, ACCEL_MAX, -target_speed);
    roboclaw.SpeedAccelM1(address2, ACCEL_MAX, target_speed);
    roboclaw.SpeedAccelM2(address2, ACCEL_MAX, target_speed);
  }

}


void subscription_02_callback(const void *msgin)
{
  if (msg_velocity.data > SPEED_MAX)
  {
    speed = SPEED_MAX;
  }
  else if (msg_velocity.data < SPEED_MIN)
  {
    speed = SPEED_MIN;
  }
  else
  {
    speed = msg_velocity.data;
  }
}


void u8g2_prepare(void)
{
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);
}


void u8g2_box_title(uint8_t a)
{
  u8g2.drawFrame(0, 0, u8g2.getDisplayWidth(), u8g2.getDisplayHeight());

  char buffer[50];

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR01: %d", (int)msg_mcu.sensor_01);
  u8g2.drawStr(10, a, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR02: %d", (int)msg_mcu.sensor_02);
  u8g2.drawStr(10, a + 10, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR03: %d", (int)msg_mcu.sensor_03);
  u8g2.drawStr(10, a + 20, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR04: %d", (int)msg_mcu.sensor_04);
  u8g2.drawStr(10, a + 30, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR05: %d", (int)msg_mcu.sensor_05);
  u8g2.drawStr(10, a + 40, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR06: %d", (int)msg_mcu.sensor_06);
  u8g2.drawStr(10, a + 50, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR07: %d", (int)msg_mcu.sensor_07);
  u8g2.drawStr(70, a, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR08: %d", (int)msg_mcu.sensor_08);
  u8g2.drawStr(70, a + 10, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "SR09: %d", (int)msg_mcu.sensor_09);
  u8g2.drawStr(70, a + 20, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "TEMP: %d", (int)msg_mcu.temperatura);
  u8g2.drawStr(70, a + 30, buffer);

  memset(buffer, '\0', 50);
  snprintf(buffer, sizeof(buffer), "HUM: %d", (int)msg_mcu.humedad);
  u8g2.drawStr(70, a + 40, buffer);
}


void draw(void)
{
  u8g2_prepare();
  switch (draw_state >> 3)
  {
  case 0:
    u8g2_box_title(4);
    break;
    // case 1: u8g2_box_frame(draw_state&7); break;
  }
}


void init_nodo(void)
{
  allocator = rcl_get_default_allocator();

  // create init_options
  RCCHECK(rclc_support_init(&support, 0, NULL, &allocator));

  // create node
  RCCHECK(rclc_node_init_default(&node, "micro_ros_arduino_node", "", &support));
}


void init_plublicador_subcriptor()
{
  // create subscriber_01

  // RCCHECK(rclc_subscription_init_default(
  //   &subscriber_01,
  //   &node,
  //   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),
  //   "micro_ros_arduino_subscriber_01"));

  RCCHECK(rclc_subscription_init_default(
      &subscriber_01,
      &node,
      ROSIDL_GET_MSG_TYPE_SUPPORT(geometry_msgs, msg, Twist),
      "/cmd_vel"));

  // msg hace referencia al tipo de mensaje y no al monbre del mensaje

  // create subscriber_02

  RCCHECK(rclc_subscription_init_default(
      &subscriber_02,
      &node,
      ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, UInt32),
      "/velocity"));

  // msg hace referencia al tipo de mensaje y no al monbre del mensaje

  // Creador publicador
  RCCHECK(rclc_publisher_init_default(
      &publisher_01,
      &node,
      ROSIDL_GET_MSG_TYPE_SUPPORT(my_custom_message, msg, McuMessage),
      "/mcu"));

  // create timer, called every 1000 ms to publish heartbeat
  const unsigned int timer_01_timeout = 1000;
  RCCHECK(rclc_timer_init_default(
      &timer_01,
      &support,
      RCL_MS_TO_NS(timer_01_timeout),
      timer_01_callback));

  // Creador publicador 02
  RCCHECK(rclc_publisher_init_default(
      &publisher_02,
      &node,
      ROSIDL_GET_MSG_TYPE_SUPPORT(my_custom_message, msg, VelocidadMotorMessage),
      "/velocidad_motor"));

  // create timer 02, called every 1000 ms to publish heartbeat
  const unsigned int timer_02_timeout = 100;
  RCCHECK(rclc_timer_init_default(
      &timer_02,
      &support,
      RCL_MS_TO_NS(timer_02_timeout),
      timer_02_callback));
}


void init_ejecutor(void)
{
  // create executor
  RCCHECK(rclc_executor_init(&executor_sub_01, &support.context, 1, &allocator));
  RCCHECK(rclc_executor_add_subscription(&executor_sub_01, &subscriber_01, &msg_velocidad, &subscription_01_callback, ON_NEW_DATA));

  RCCHECK(rclc_executor_init(&executor_sub_02, &support.context, 1, &allocator));
  RCCHECK(rclc_executor_add_subscription(&executor_sub_02, &subscriber_02, &msg_velocity, &subscription_02_callback, ON_NEW_DATA));

  RCCHECK(rclc_executor_init(&executor_pub_01, &support.context, 1, &allocator));
  RCCHECK(rclc_executor_add_timer(&executor_pub_01, &timer_01));

  RCCHECK(rclc_executor_init(&executor_pub_02, &support.context, 1, &allocator));
  RCCHECK(rclc_executor_add_timer(&executor_pub_02, &timer_02));
}


void fini_publicador_subcriptor(void)
{
  rcl_publisher_fini(&publisher_01, &node);
  rcl_publisher_fini(&publisher_02, &node);
  rcl_subscription_fini(&subscriber_01, &node);
  rcl_subscription_fini(&subscriber_02, &node);
}


void fini_nodo(void)
{
  rcl_node_fini(&node);
}

void error_loop_loop()
{
  roboclaw.SpeedAccelM1(address1, ACCEL_MAX, 0);
  roboclaw.SpeedAccelM2(address1, ACCEL_MAX, 0);
  roboclaw.SpeedAccelM1(address2, ACCEL_MAX, 0);
  roboclaw.SpeedAccelM2(address2, ACCEL_MAX, 0);
  roboclaw.ForwardM1(address1, 0);
  roboclaw.ForwardM2(address1, 0);
  roboclaw.ForwardM1(address2, 0);
  roboclaw.ForwardM2(address2, 0);
  f_error_ros = 1;
  while (f_error_ros)
  {
    digitalWrite(pin_piloto_rojo, !digitalRead(pin_piloto_rojo));
    delay(100);
    while (Serial.dtr() == 0)
    {
      static int i;
      digitalWrite(LED_PIN, (i++) % 2);
      digitalWrite(pin_piloto_rojo, 1);
      delay(500);
      digitalWrite(pin_piloto_rojo, 0);
      delay(900);
    }
    f_error_ros = 0;
  }
  digitalWrite(pin_piloto_rojo, 0);
  fini_publicador_subcriptor();
  fini_nodo();

  delay(100);

  init_nodo();
  init_plublicador_subcriptor();
  init_ejecutor();
}

void setup()
{

  // set_microros_transports();
  // Configure serial transport
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);

  pinMode(DOUT_OE, OUTPUT);
  digitalWrite(DOUT_OE, 0);

  pinMode(RELAY_2, OUTPUT);
  pinMode(RELAY_3, OUTPUT);

  pinMode(pin_piloto_amarillo, OUTPUT);
  pinMode(pin_piloto_rojo, OUTPUT);

  digitalWrite(pin_piloto_amarillo, 1);
  delay(2000);
  digitalWrite(pin_piloto_amarillo, 0);

  digitalWrite(pin_piloto_rojo, 1);
  delay(2000);
  digitalWrite(pin_piloto_rojo, 0);

  digitalWrite(RELAY_2, 0);
  digitalWrite(RELAY_3, 0);

  Serial.begin(115200);
  set_microros_serial_transports(Serial);
  delay(2000);

  while (Serial.dtr() == 0)
  {
    static int i;
    // Serial7.println("No usb host");
    digitalWrite(LED_PIN, (i++) % 2);
    digitalWrite(pin_piloto_amarillo, 1);
    delay(500);
    digitalWrite(pin_piloto_amarillo, 0);
    delay(900);
  }

  digitalWrite(pin_piloto_amarillo, 0);
  digitalWrite(RELAY_3, 1);
  digitalWrite(RELAY_2, 1);
  delay(500);
  digitalWrite(RELAY_2, 0);
  delay(900);

  digitalWrite(RELAY_2, 0);
  digitalWrite(RELAY_3, 0);

  delay(2000);

  init_nodo();

  init_plublicador_subcriptor();

  init_ejecutor();

  roboclaw.begin(38400);

  // Asignar paramatros del PID
  roboclaw.SetM1VelocityPID(address1, Kd, Kp, Ki, qpps);
  roboclaw.SetM2VelocityPID(address1, Kd, Kp, Ki, qpps);
  roboclaw.SetM1VelocityPID(address2, Kd, Kp, Ki, qpps);
  roboclaw.SetM2VelocityPID(address2, Kd, Kp, Ki, qpps);

  pinMode(29, OUTPUT);
  digitalWrite(29, 0);

  u8g2.begin();

  pinMode(pin_tijeral_limite_superior, INPUT);
  pinMode(pin_tijeral_limite_inferior, INPUT);

  Wire2.begin();
  ADS.begin();
  ADS.setGain(2); // ADS1X15_PGA_2_048V
}

void loop()
{
  if ((millis() - cont_00) >= PERIODO_00)
  {

    if (rmw_uros_ping_agent(100, 3) != RMW_RET_OK)
    {

      roboclaw.SpeedAccelM1(address1, ACCEL_MAX, 0);
      roboclaw.SpeedAccelM2(address1, ACCEL_MAX, 0);
      roboclaw.SpeedAccelM1(address2, ACCEL_MAX, 0);
      roboclaw.SpeedAccelM2(address2, ACCEL_MAX, 0);
      roboclaw.ForwardM1(address1, 0);
      roboclaw.ForwardM2(address1, 0);
      roboclaw.ForwardM1(address2, 0);
      roboclaw.ForwardM2(address2, 0);

      digitalWrite(pin_piloto_rojo, 1);
      delay(2000);
      digitalWrite(pin_piloto_rojo, 0);
      delay(1000);
      digitalWrite(pin_piloto_rojo, 1);
      delay(2000);
      digitalWrite(pin_piloto_rojo, 0);

      SCB_AIRCR = 0x05FA0004;
    }
    else
    {
      RCLOOPCHECK(rclc_executor_spin_some(&executor_sub_01, RCL_MS_TO_NS(100)));
      RCLOOPCHECK(rclc_executor_spin_some(&executor_sub_02, RCL_MS_TO_NS(100)));
      RCLOOPCHECK(rclc_executor_spin_some(&executor_pub_01, RCL_MS_TO_NS(100)));
      RCLOOPCHECK(rclc_executor_spin_some(&executor_pub_02, RCL_MS_TO_NS(100)));
    }
    cont_00 = millis();
  }

  if (millis() - cont_01 >= PERIODO_01)
  {
    cont_01 = millis();

    // picture loop
    u8g2.firstPage();
    do
    {
      draw();
    } while (u8g2.nextPage());

    // increase the state
    draw_state++;
    if (draw_state >= 1 * 8)
      draw_state = 0;

    // delay between each page
  }

  if (millis() - cont_02 >= PERIODO_02)
  {
    cont_02 = millis();

    bat = read_battery_voltage();
    temperatura = 0.0;
    humedad = 0.0;
    if (dht22.read2(&temperatura, &humedad, NULL) != SimpleDHTErrSuccess)
    {
      temperatura = 0.0;
      humedad = 0.0;
    }
  }
}
